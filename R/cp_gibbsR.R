# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title A Gibbs sampler using Rcpp
#' @description A Gibbs sampler using Rcpp
#' @param length_of_chains the number of samples
#' @param from_point how many number ahead are to abandon
#' @param a,b the shape of distribution Y = beta(x+a,n-x+b)
#' @param x_range = n the X values uses in distribution X = Binomial(n, y)
#' @param mu_x,mu_y the expectation of X and Y
#' @return a random sample of size \code{n}
#' @examples
#' \dontrun{
#' ZC <- cp_gibbsC()
#' }
#' @importFrom stats rbeta rbinom
#' @export
cp_gibbsR <- function(length_of_chains = 1e4,from_point = 1001, a = 1, b = 1, x_range = 10, mu_x = NA, mu_y = NA){
  ## length_of_chains: the whole chain length
  ## from_point: from which point to output, notice we actually generate 1e4 + 1000, because we have to dump the first 1000 points
  ## a, b: they are in the beta parameters
  ## x_range: the n parameter in Binomial(n,y)
  ## mu_x.mu_y: the beginning value of this chain
  to_point = length_of_chains + from_point - 1
  Z <- matrix(0,nrow = to_point,ncol = 2)
  # Z initialize
  if (is.na(mu_x) | is.na(mu_y)){
    # condition 1: x0 is not defined
    Z[1,2] <- a/(a+b)
    Z[1,1] <- x_range * Z[1,2]
  } else {
    # condition 2: x0 is defined
    Z[1,] <- c(mu_x,mu_y)
  }
  for (i in 2:to_point){
    # update X
    Zy <- Z[i-1,2]
    Z[i,1] <- rbinom(1,x_range,Zy)
    # update Y
    Zx <- Z[i,1]
    Z[i,2] <- rbeta(1,Zx+a,x_range-Zx+b)
  }
  return(Z[from_point:to_point,])
}
